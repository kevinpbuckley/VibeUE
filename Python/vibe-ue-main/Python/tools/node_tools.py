"""
Unified Blueprint node management tools for the VibeUE MCP server.

This module provides a unified interface for performing various operations on Blueprint nodes,
such as adding, removing, and connecting nodes, as well as managing Blueprint functions and variables.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from mcp.server.fastmcp import Context, FastMCP

logger = logging.getLogger("UnrealMCP")


def _merge(target: Dict[str, Any], values: Dict[str, Any]) -> None:
    """Merge non-``None`` values into ``target`` in-place."""
    for key, value in values.items():
        if value is not None:
            target[key] = value


def register_blueprint_node_tools(mcp: FastMCP) -> None:
    """Register unified Blueprint node MCP tools."""

    def _dispatch(command: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        from vibe_ue_server import get_unreal_connection

        unreal = get_unreal_connection()
        if not unreal:
            logger.error("Failed to connect to Unreal Engine")
            return {"success": False, "message": "Failed to connect to Unreal Engine"}

        logger.info("Dispatching %s with payload: %s", command, payload)
        response = unreal.send_command(command, payload)
        if not response:
            logger.error("No response from Unreal Engine")
            return {"success": False, "message": "No response from Unreal Engine"}

        logger.debug("%s response: %s", command, response)
        return response

    @mcp.tool()
    def manage_blueprint_node(
        ctx: Context = None,  # ‚úÖ Made optional - framework should inject, but AI doesn't need to pass it
        blueprint_name: str = None,
        action: str = None,
        graph_scope: str = "event",
        function_name: Optional[str] = None,
        node_id: Optional[str] = None,
        node_identifier: Optional[str] = None,
        node_type: Optional[str] = None,
        node_params: Optional[Dict[str, Any]] = None,
        node_config: Optional[Dict[str, Any]] = None,
        position: Optional[List[float]] = None,
        node_position: Optional[List[float]] = None,
        source_node_id: Optional[str] = None,
        source_pin: Optional[str] = None,
        target_node_id: Optional[str] = None,
        target_pin: Optional[str] = None,
        disconnect_pins: Optional[bool] = None,
        property_name: Optional[str] = None,
        property_value: Optional[Any] = None,
        include_functions: Optional[bool] = None,
        include_macros: Optional[bool] = None,
        include_timeline: Optional[bool] = None,
        extra: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        üõ†Ô∏è **MULTI-ACTION BLUEPRINT NODE MANAGER**: Universal tool for all Blueprint node operations.

        ‚ú® **External Targets Supported (Sept 2025)**: Supply the optional metadata fields below to spawn fully configured
        nodes for engine helpers and Blueprint casts without manual cleanup.
        - `node_params.function_name` + `node_params.function_class` (or `FunctionReference.MemberParent`) for
          static/global calls such as `UGameplayStatics::GetPlayerController`.
        - `node_params.cast_target` (soft class path or Blueprint class name) for `Cast To <Class>` nodes.
        The server now resolves these descriptors, loads the referenced class, and reconstructs the node so the expected
        pins appear immediately.

        ## Supported Actions:
        - **create**: Create new nodes (use spawner_key from get_available_blueprint_nodes() for exact creation)
        - **connect**: Connect pins between nodes (requires source/target node_id and pin names)
        - **connect_pins**: Batch connect pins with schema validation, conversion helpers, and diagnostics
        - **disconnect**: Disconnect pins (requires source/target node_id and pin names)
        - **disconnect_pins**: Break specific links or clear entire pins using the new payload format
        - **delete**: Remove nodes (requires node_id)
        - **move**: Reposition nodes (requires node_id and position)
        - **list**: List all nodes in graph (returns node inventory)
        - **describe**: Rich node + pin metadata payload (deterministic ordering)
    - **reset_pin_defaults**: Restore specified pins (or every pin) to their autogenerated default values
        - **get_details**: Get detailed node information (requires node_id)
    - **configure**: Apply node configuration including property updates and pin operations (split/recombine)
    - **split** / **split_pins**: Split struct pins into sub-pins (requires node_id and pin names)
    - **recombine** / **recombine_pins** / **unsplit**: Collapse previously split pins back into their parent pin
        - **refresh_node**: Reconstruct a single Blueprint node (equivalent to right-click ‚Üí Refresh Node)
        - **refresh_nodes**: Refresh every node in the Blueprint (mirrors Blueprint ‚Üí Refresh All Nodes)

        ## Context Requirements:
        - **graph_scope**: "event" (Event Graph) or "function" (Function Graph)
        - **function_name**: Required when graph_scope="function" - specify target function name
        - **blueprint_name**: Always required - target Blueprint name

        ## Multi-Action Usage Patterns:

        ### Pattern 1: Descriptor-Based Node Creation (RECOMMENDED Oct 2025)
        ```python
        # üÜï BEST PRACTICE: Use spawner_key for exact node creation
        
        # 1. Discover with complete metadata (returns descriptors by default)
        nodes = get_available_blueprint_nodes(
            blueprint_name="/Game/Blueprints/BP_Player",
            search_term="GetPlayerController"
        )
        
        # 2. AI examines ALL variants with complete info:
        # - "GameplayStatics::GetPlayerController" (3 input pins, static)
        # - "CheatManager::GetPlayerController" (1 pin, instance method)
        
        # 3. Create using EXACT spawner_key (NO AMBIGUITY!)
        result = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            graph_scope="function",
            function_name="MyFunction",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        # ‚úÖ Result: Exact variant created, correct pin count guaranteed!
        ```

        ### Pattern 2: Legacy Node Creation (Fuzzy Search)
        ```python
        # ‚ö†Ô∏è LEGACY: Using node_type triggers fuzzy search (less reliable)
        nodes = get_available_blueprint_nodes("BP_Player", category="Flow Control")
        result = manage_blueprint_node("BP_Player", action="create", node_type="Branch")
        node_id = result["node_id"]
        manage_blueprint_node("BP_Player", action="move", node_id=node_id, position=[200, 100])
        ```

        ### Pattern 3: Node Connection Workflow
        ```python
        # List ‚Üí Identify ‚Üí Connect ‚Üí Verify
        nodes = manage_blueprint_node("BP_Player", action="list", graph_scope="function", 
                                     function_name="MyFunction")
        
        # ‚úÖ CORRECT: Use connect_pins with extra parameter containing connections array
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="connect_pins",
            graph_scope="function",
            function_name="MyFunction",
            extra={
                "connections": [{
                    "source_node_id": "NODE_GUID_1",
                    "source_pin_name": "ReturnValue",
                    "target_node_id": "NODE_GUID_2",
                    "target_pin_name": "InputValue"
                }]
            }
        )
        ```

        ### Pattern 4: Function Graph Operations
        ```python
        # Function context requires function_name
        manage_blueprint_node("BP_Player", action="create", graph_scope="function",
                              function_name="CalculateHealth", node_type="Add", position=[100, 50])
        ```

        ### Pattern 5: Refreshing nodes to clear stale state
        ```python
        # Rebuild a single node (same as right-click ‚Üí Refresh Node)
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="refresh_node",
            node_id="{NODE_GUID}"
        )

        # Refresh every node in the Blueprint (Blueprint ‚Üí Refresh All Nodes)
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="refresh_nodes"
        )
        ```

        ### Pattern 6: Resetting stale default values
        ```python
        # Clear a single pin back to its autogenerated default
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="reset_pin_defaults",
            node_id="{NODE_GUID}",
            extra={"pins": ["In Widget To Focus"]}
        )

        # Reset every pin on the node and compile afterwards
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="reset_pin_defaults",
            node_id="{NODE_GUID}",
            extra={"reset_all": True, "compile": True}
        )
        ```

        ## üîå Pin Connection System (CRITICAL):

        ### ‚úÖ CORRECT Connection Format:
        
        The `connect_pins` action requires connections to be passed via the `extra` parameter:
        
        ```python
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="connect_pins",
            graph_scope="function",
            function_name="MyFunction",
            extra={
                "connections": [
                    {
                        "source_node_id": "F937A5914C523D1AB3532C8C4125C0B7",  # Node GUID
                        "source_pin_name": "ReturnValue",                      # Pin name
                        "target_node_id": "64DE8C1B47F7EEDA2B713B8604257954",  # Node GUID
                        "target_pin_name": "self"                              # Pin name
                    },
                    # Multiple connections can be made at once
                    {
                        "source_node_id": "64DE8C1B47F7EEDA2B713B8604257954",
                        "source_pin_name": "ReturnValue",
                        "target_node_id": "B3DC700344C6DA7C35FD48B872A57458",
                        "target_pin_name": "Object"
                    }
                ]
            }
        )
        ```
        
        ### üìã Getting Node IDs and Pin Names:
        
        Use `action="describe"` to get node GUIDs and pin names:
        
        ```python
        # Get all nodes and their pins
        result = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="describe",
            graph_scope="function",
            function_name="MyFunction"
        )
        
        # Result contains nodes with:
        # - node_id: "{GUID}" format
        # - pins: array with pin_id and name for each pin
        ```
        
        ### Connection Payload Fields:
        
        Each connection object can contain:
        - **source_node_id** (required): Source node GUID
        - **source_pin_name** (required): Name of source pin
        - **target_node_id** (required): Target node GUID  
        - **target_pin_name** (required): Name of target pin
        - **allow_conversion_node** (optional): Allow automatic conversion nodes (default: true)
        - **allow_promotion** (optional): Allow type promotion/array wrapping (default: true)
        - **break_existing_links** (optional): Break existing connections first (default: true)

                ## üîß Pin Split/Recombine Patterns

                - Use `action="split"` (or `"split_pins"`) with `extra={"pins": ["MyStruct"]}` to split one or more struct pins.
                - Use `action="recombine"` / `"unsplit"` with the same payload shape to collapse sub-pins back into the parent pin.
                - Alternatively, call `action="configure"` and pass
                    ```python
                    node_config={
                            "pin_operations": [
                                    {"action": "split", "pin": "MyStruct"},
                                    {"action": "recombine", "pin": "OldStruct"}
                            ]
                    }
                    ```
                    to batch property edits and pin transforms in a single request.

        ## Action-Specific Parameters:

        **create**: 
        - **RECOMMENDED**: node_params with spawner_key (from get_available_blueprint_nodes)
        - **LEGACY**: node_type (triggers fuzzy search, less reliable)
        - **position**: [X, Y] coordinates for node placement (CRITICAL for readable layouts)
          - X increases to the RIGHT (left-to-right flow)
          - Y increases DOWNWARD
          - **Best Practice**: Use increasing X values (e.g., [0, 100], [300, 100], [600, 100]) for left-to-right execution flow
          - **Common Mistake**: Decreasing X values creates backward/unreadable graphs
          - Typical spacing: 250-400 units horizontal, 100-200 units vertical
        - node_params (CRITICAL for variable nodes, casts, and exact node creation)
        
        **connect_pins**: extra with connections array (see above) ‚úÖ USE THIS FOR CONNECTIONS
        **disconnect_pins**: extra with connections array or pin_ids list
        **delete**: node_id
        **move**: node_id, position
        **list**: (no additional parameters)
        **describe**: node_id (optional - if omitted, describes all nodes)
        **configure**: node_id, property_name, property_value
    **refresh_node**: node_id or node_identifier required; optional `compile` (default `True`) to auto-compile after refresh
    **refresh_nodes**: blueprint-level refresh; optional `compile` (default `True`)
            - Pass `extra={"compile": False}` to skip the compile step when needed

        ## üîë node_params Patterns (VALIDATED Oct 2025):

        ### üÜï Spawner Key (EXACT NODE CREATION - RECOMMENDED)
        ```python
        # Get spawner_key from discovery
        nodes = get_available_blueprint_nodes(
            blueprint_name="/Game/Blueprints/BP_Player",
            search_term="GetPlayerController"
        )
        
        # Use spawner_key for exact creation
        manage_blueprint_node(
            action="create",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        # ‚úÖ Creates EXACT variant with correct pin count
        # ‚úÖ No ambiguity, no fuzzy searching, no wrong variants
        # ‚ö†Ô∏è Spawner keys mirror the Blueprint palette display text. When copying names that
        #    include underscores (e.g., variables like ``Death_Niagara_System``), replace
        #    them with spaces so the key matches the node title (``GET Death Niagara System``).
        #    The tool now performs this normalization automatically, but copying the exact
        #    descriptor text avoids ambiguity.
        ```

        ### Variable Set Nodes ‚úÖ REQUIRED
        ```python
        manage_blueprint_node(
            action="create",
            node_type="SET Microsub HUD",  # or "Set Microsub HUD"
            node_params={"variable_name": "Microsub HUD"},  # ‚Üê CRITICAL!
            position=[1100, 100]
        )
        # Creates 5-pin node: execute, then, Microsub HUD (input), Output_Get
        # Without node_params: Only 2 pins (broken node)
        ```

        ### Variable Get Nodes ‚úÖ REQUIRED
        ```python
        manage_blueprint_node(
            action="create",
            node_type="GET Health",  # or "Get Health"
            node_params={"variable_name": "Health"},  # ‚Üê CRITICAL!
            position=[100, 50]
        )
        # Creates proper getter with value output pin
        ```

        ### Cast Nodes ‚úÖ REQUIRED for Blueprint Classes
        ```python
        manage_blueprint_node(
            action="create",
            node_type="Cast To BP_MicrosubHUD",
            node_params={
                "cast_target": "/Game/Blueprints/HUD/BP_MicrosubHUD.BP_MicrosubHUD_C"
            },  # ‚Üê CRITICAL! Full path + _C suffix
            position=[800, 100]
        )
        # Creates 6-pin node with typed output: execute, then, CastFailed, Object, AsBP Microsub HUD
        # Format: /Full/Package/Path/BP_ClassName.BP_ClassName_C
        ```

        ### Function Call Nodes ‚ö†Ô∏è SITUATIONAL
        ```python
        # Most function calls work without node_params
        manage_blueprint_node(
            action="create",
            node_type="Get HUD",
            position=[500, 100]
        )
        
        # Known Issue: "Get Player Controller" shows CheatManager warning
        # Workaround: Works correctly despite warning (C++ fix planned)
        manage_blueprint_node(
            action="create",
            node_type="Get Player Controller",
            position=[200, 100]
        )
        # Shows warning but ReturnValue is correct PlayerController type
        ```

        ## ‚úÖ Validation Workflow:
        ```python
        # 1. Create node with node_params
        result = manage_blueprint_node(
            action="create",
            node_type="SET Health",
            node_params={"variable_name": "Health"}
        )
        
        # 2. Validate pin count (CRITICAL!)
        expected_pins = {
            "variable_set": 5,    # execute, then, value_input, Output_Get
            "variable_get": 2,    # value_output (+ optional self)
            "cast": 6,            # execute, then, CastFailed, Object, AsCastTarget
        }
        
        # 3. If pin_count < expected, node configuration failed
        if result.get("pin_count", 0) < expected_pins["variable_set"]:
            print("‚ö†Ô∏è Node missing pins - check node_params!")
        
        # 4. Use describe to inspect before connecting
        manage_blueprint_node(
            action="describe",
            extra={"node_id": result["node_id"]}
        )
        ```

        ## Common Pin Names by Node Type:
        
        - **Function Entry**: "then" (exec output)
        - **Function Call**: "self" (target input), "ReturnValue" (output), "execute" (exec input)
        - **Cast Node**: "execute" (exec in), "then" (exec out success), "CastFailed" (exec out fail), "Object" (cast input), "As[ClassName]" (typed output)
        - **Variable Get**: Variable name (output)
        - **Variable Set**: "execute" (exec in), "then" (exec out), Variable name (value input), "Output_Get" (optional)
        - **Branch**: "execute" (exec in), "Condition" (bool input), "True" (exec out), "False" (exec out)

        ## üéØ Node Creation Best Practices:

        ### ‚úÖ RECOMMENDED: Descriptor-Based Creation (Oct 2025)
        ```python
        # 1. Use get_available_blueprint_nodes() with default return_descriptors=True
        nodes = get_available_blueprint_nodes(
            blueprint_name="/Game/Blueprints/BP_Player",
            search_term="GetPlayerController"
        )
        
        # 2. Examine spawner_key, expected_pin_count, function_metadata
        # - "GameplayStatics::GetPlayerController" ‚Üí 4 pins (exec + 3 data pins)
        # - "CheatManager::GetPlayerController" ‚Üí 2 pins (exec + 1 data pin)
        
        # 3. Create with exact spawner_key
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"}
        )
        # Result: EXACT variant, guaranteed correct pin count!
        ```

        ### ‚ö†Ô∏è LEGACY: Fuzzy Search (Less Reliable)
        ```python
        # Old way: Uses fuzzy search, may create wrong variant
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            node_type="Get Player Controller"  # Ambiguous!
        )
        # May create CheatManager variant instead of GameplayStatics
        ```
        
        üìñ **Troubleshooting**:
        | Problem | Cause | Solution |
        |---------|-------|----------|
        | Variable Set has only 2 pins | Missing node_params.variable_name | Add variable_name to node_params |
        | Cast shows generic Object type | Missing node_params.cast_target | Add full Blueprint path with _C suffix |
        | Function shows wrong context | C++ plugin issue (Get Player Controller) | Use anyway - output type is correct |
        | Pins don't match original BP | Wrong node_type or missing node_params | Use get_available_blueprint_nodes() first |
    | Warnings about missing overrides | Node cache is stale after structural edits | Call `manage_blueprint_node(..., action="refresh_node")` |

        üîß **Advanced Multi-Action Examples**:
        ```python
        # Create variable getter, position it, connect to branch
        getter = manage_blueprint_node("BP_Player", "create", node_type="Get Health")
        manage_blueprint_node("BP_Player", "move", node_id=getter["node_id"], position=[0, 100])
        manage_blueprint_node("BP_Player", "connect",
                              source_node_id=getter["node_id"], source_pin="Health",
                              target_node_id="Branch_1", target_pin="Condition")
        ```
        """

        normalized_node_params = node_params

        payload: Dict[str, Any] = {
            "blueprint_name": blueprint_name,
            "action": action,
            "graph_scope": graph_scope,
        }

        resolved_node_type = node_type or node_identifier
        _merge(
            payload,
            {
                "function_name": function_name,
                "node_id": node_id,
                "node_type": resolved_node_type,
                "node_identifier": resolved_node_type,
                "node_params": normalized_node_params,
                "node_config": node_config,
                "position": position,
                "node_position": node_position,
                "source_node_id": source_node_id,
                "source_pin": source_pin,
                "target_node_id": target_node_id,
                "target_pin": target_pin,
                "disconnect_pins": disconnect_pins,
                "property_name": property_name,
                "property_value": property_value,
                "include_functions": include_functions,
                "include_macros": include_macros,
                "include_timeline": include_timeline,
            },
        )

        if extra:
            _merge(payload, extra)

        # Debug logging to understand parameter passing
        logger.info(f"manage_blueprint_node final payload: {payload}")

        # Avoid duplicating identical node configuration dictionaries
        if payload.get("node_config") is payload.get("node_params"):
            payload.pop("node_config", None)

        return _dispatch("manage_blueprint_node", payload)

    @mcp.tool()
    def get_available_blueprint_nodes(
        blueprint_name: str,
        category: str = "",
        search_term: str = "",
        graph_scope: str = "event",
        include_functions: bool = True,
        include_variables: bool = True,
        include_events: bool = True,
        max_results: int = 100,
        return_descriptors: bool = True,
    ) -> Dict[str, Any]:
        """
        üîç **ESSENTIAL NODE DISCOVERY TOOL**: Get all available Blueprint node types with complete metadata.
        
        üéØ **NEW (Oct 2025)**: Now returns complete node descriptors including:
        - **spawner_key**: Unique identifier for exact node creation (e.g., "GameplayStatics::GetPlayerController")
        - **expected_pin_count**: Number of pins the node will have
        - **function_class_path**: Full UE path to function class
        - **pins**: Complete pin metadata with types and directions
        - **is_static**, **is_pure**, **is_const**: Function properties
        
        ‚ö†Ô∏è **USE THIS FIRST**: Always call this before manage_blueprint_node(action='create') to discover
        exact node type names and spawner_keys. This prevents "unknown node type" errors and ensures reliable node creation.
        
        üéØ **PRIMARY USE CASES**:
        - **Before Creating Nodes**: Find exact node type names (e.g., "Branch", "Print String", "Cast To Object")
        - **Node Type Resolution**: When you know what you want to do but need the precise node name
        - **Category Exploration**: Browse available nodes by category (Flow Control, Math, Variables, etc.)
        - **Function-Specific Nodes**: Discover nodes available in different graph contexts
        
        üîÑ **TYPICAL AI WORKFLOW**:
        ```python
        # 1. User says: "Create a GetPlayerController node"
        nodes = get_available_blueprint_nodes("BP_Player", search_term="GetPlayerController")
        
        # 2. Result now includes spawner_key for each variant:
        # {
        #   "categories": {
        #     "|Game": [
        #       {
        #         "name": "Get Player Controller",
        #         "spawner_key": "GameplayStatics::GetPlayerController",
        #         "expected_pin_count": 3,
        #         "function_class": "GameplayStatics",
        #         "is_static": true,
        #         "pins": [...]
        #       },
        #       {
        #         "name": "Get Player Controller", 
        #         "spawner_key": "CheatManager::GetPlayerController",
        #         "expected_pin_count": 1,
        #         "function_class": "CheatManager",
        #         "is_static": false,
        #         "pins": [...]
        #       }
        #     ]
        #   }
        # }
        
        # 3. Use exact spawner_key for creation (NO AMBIGUITY!)
        manage_blueprint_node(
            blueprint_name="BP_Player", 
            action="create",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        ```
        
        üìä **Search Strategies**:
        - **By Intent**: category="Flow Control" for conditionals, loops
        - **By Function**: category="Math" for calculations
        - **By Action**: category="Variables" for data operations  
        - **By Context**: graph_scope="function" vs "event" for appropriate nodes
        
        Args:
            blueprint_name: Name of the target Blueprint to get nodes for
            category: Filter by node category (Flow Control, Math, Variables, Functions, etc.)
            search_term: Text filter for node names, descriptions, and keywords (like Unreal's Add Action search)
            graph_scope: Context for node discovery ("event" for Event Graph, "function" for Function Graph)
            include_functions: Whether to include function call nodes
            include_variables: Whether to include variable get/set nodes
            include_events: Whether to include event nodes  
            max_results: Maximum number of nodes to return (default: 100)
            return_descriptors: Whether to return complete descriptors with spawner_key (default: True)
            
        Returns:
            Dict containing:
            - success: boolean indicating if discovery completed
            - categories: dict of node categories with arrays of available nodes
            - total_nodes: total number of nodes found
            - error: string (only if success=false)
            
        üìä **Node Metadata Structure** (when return_descriptors=True):
        Each discovered node includes:
        - name: Exact node type name to use in manage_blueprint_node
        - spawner_key: Unique identifier for exact creation (e.g., "GameplayStatics::GetPlayerController")
        - category: Node category for organization
        - description: What the node does
        - keywords: Search terms for semantic discovery
        - type: Node classification (function_call, variable_get, etc.)
        - expected_pin_count: Total pins this node will have
        - function_class: Class name (for function nodes)
        - function_class_path: Full UE path to class
        - is_static: Whether function is static
        - is_pure: Whether function is pure (no exec pins)
        - pins: Array of complete pin descriptors with names, types, directions
        
        üí° **Smart Usage Examples**:
        ```python
        # Find print/debug nodes
        get_available_blueprint_nodes("BP_Player", category="Development")
        
        # Search for "Play Sound" nodes like Unreal's Add Action menu
        get_available_blueprint_nodes("BP_Player", search_term="Play Sound")
        
        # Find mathematical operations
        get_available_blueprint_nodes("BP_Player", category="Math")
        
        # Search for specific functions - find all "Location" related nodes
        get_available_blueprint_nodes("BP_Player", search_term="Location")
        
        # Combined filtering: Audio category with "Play" in the name
        get_available_blueprint_nodes("BP_Player", category="Audio", search_term="Play")
        
        # Find variable operations
        get_available_blueprint_nodes("BP_Player", category="Variables")
        ```
        
        üéØ **AI Integration**: This tool enables data-driven Blueprint development by providing
        exact node names that work reliably, eliminating guesswork and trial-and-error.
        
        ‚ö†Ô∏è **CRITICAL: node_params Requirements** (Validated Oct 3, 2025):
        
        Some node types REQUIRE `node_params` in manage_blueprint_node() to work correctly:
        
        **Variable Set Nodes** (REQUIRED):
        - Must include: `node_params={"variable_name": "VariableName"}`
        - Without it: Creates broken 2-pin node (only execute, then)
        - With it: Creates proper 5-pin node with value input
        - Example:
          ```python
          manage_blueprint_node(
              action="create",
              node_type="SET Health",
              node_params={"variable_name": "Health"}
          )
          ```
        
        **Variable Get Nodes** (REQUIRED):
        - Must include: `node_params={"variable_name": "VariableName"}`
        - Example:
          ```python
          manage_blueprint_node(
              action="create", 
              node_type="GET Health",
              node_params={"variable_name": "Health"}
          )
          ```
        
        **Cast Nodes** (REQUIRED for Blueprint types):
        - Must include: `node_params={"cast_target": "/Full/Path/BP_Class.BP_Class_C"}`
        - Format: Full package path + "." + ClassName + "_C"
        - Without it: Creates generic cast with wrong type
        - With it: Creates typed cast with proper Blueprint class
        - Example:
          ```python
          manage_blueprint_node(
              action="create",
              node_type="Cast To BP_MicrosubHUD",
              node_params={
                  "cast_target": "/Game/Blueprints/HUD/BP_MicrosubHUD.BP_MicrosubHUD_C"
              }
          )
          ```
        
        **Function Call Nodes** (SITUATIONAL):
        - Some functions may show compiler warnings with wrong context
        - Known issue: "Get Player Controller" creates CheatManager context
        - Workaround: Node works correctly despite warning
        - C++ plugin fix planned for future release
        
        üîß **Validation Tip**:
        After creating complex nodes, use `manage_blueprint_node(action="describe")` 
        to verify pin count and configuration before connecting.
        
        üìñ **See Also**:
        - `manage_blueprint_node()` for creation with node_params
        - node-tools-improvements.md for complete patterns guide
        """
        
        payload = {
            "blueprint_name": blueprint_name,
            "category": category,
            "search_term": search_term,
            "graph_scope": graph_scope,
            "include_functions": include_functions,
            "include_variables": include_variables,
            "include_events": include_events,
            "max_results": max_results,
            "return_descriptors": return_descriptors,
        }

        return _dispatch("get_available_blueprint_nodes", payload)

    # ‚ö†Ô∏è REMOVED Oct 4, 2025: discover_blueprint_nodes_with_descriptors tool
    # Functionality merged into get_available_blueprint_nodes(return_descriptors=True)
    # This maintains a cleaner API with a single unified discovery tool

    @mcp.tool()
    def manage_blueprint_function(
        ctx: Context = None,  # ‚úÖ Made optional - framework should inject, but AI doesn't need to pass it
        blueprint_name: str = None,
        action: str = None,
        function_name: Optional[str] = None,
        param_name: Optional[str] = None,
        direction: Optional[str] = None,
        type: Optional[str] = None,
        new_type: Optional[str] = None,
        new_name: Optional[str] = None,
        properties: Optional[Dict[str, Any]] = None,
        extra: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        üîß **MULTI-ACTION BLUEPRINT FUNCTION MANAGER**: Complete Blueprint function lifecycle management.
        
        ‚ö†Ô∏è **CRITICAL: All action names are case-insensitive and processed as lowercase by C++ backend**
        
        ## üìã Complete Action Reference (All Available Actions):
        
        ### Discovery & Inspection Actions
        
        **list** - List all functions in Blueprint
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="list"
        )
        # Returns: {"functions": [{"name": "FuncName", "node_count": 5}, ...]}
        ```
        
        **get** - Get detailed function information (‚ö†Ô∏è NOT "get_info"!)
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="get",
            function_name="CalculateHealth"
        )
        # Returns: {"name": "CalculateHealth", "node_count": 10, "graph_guid": "..."}
        ```
        
        **list_params** - List all function parameters (inputs, outputs, locals)
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="list_params",
            function_name="CalculateHealth"
        )
        # Returns: {"success": true, "function_name": "CalculateHealth", 
        #           "parameters": [{"name": "BaseHealth", "direction": "input", "type": "float"}, ...],
        #           "count": 2}
        ```
        
        ### Function Lifecycle Actions
        
        **create** - Create new custom function
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            function_name="CalculateHealth"
        )
        # Returns: {"success": true, "function_name": "CalculateHealth", "graph_guid": "..."}
        ```
        
        **delete** - Remove function from Blueprint
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="delete",
            function_name="OldFunction"
        )
        # Returns: {"success": true, "function_name": "OldFunction"}
        ```
        
        ### Parameter Management Actions
        
        **add_param** - Add input/output parameter to function
        ```python
        # Add input parameter
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="add_param",
            function_name="CalculateHealth",
            param_name="BaseHealth",
            direction="input",  # ‚ö†Ô∏è Use "input" or "out" (NOT "output"!)
            type="float"
        )
        
        # Add output parameter (‚ö†Ô∏è direction must be "out" not "output"!)
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="add_param",
            function_name="CalculateHealth",
            param_name="ResultHealth",
            direction="out",  # ‚úÖ CORRECT: "out" for output parameters
            type="float"
        )
        
        # Add object reference parameter
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="add_param",
            function_name="ProcessActor",
            param_name="TargetActor",
            direction="input",
            type="object:ABP_Enemy_C"  # Format: "object:ClassName"
        )
        ```
        
        **remove_param** - Remove parameter from function
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="remove_param",
            function_name="CalculateHealth",
            param_name="OldParam",
            direction="input"  # Specify which direction to remove from
        )
        ```
        
        **update_param** - Update parameter type or name
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="update_param",
            function_name="CalculateHealth",
            param_name="OldParamName",
            direction="input",
            new_type="int",  # Optional: change type
            new_name="NewParamName"  # Optional: rename
        )
        ```
        
        ### Local Variable Actions
        
        **list_locals** - List all local variables in function (aliases: "locals", "list_local_vars")
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="list_locals",
            function_name="CalculateHealth"
        )
        ```
        
        **add_local** - Add local variable to function
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="add_local",
            function_name="CalculateHealth",
            param_name="TempResult",  # ‚ö†Ô∏è Uses param_name for local variable name
            type="float"
        )
        ```
        
        **remove_local** - Remove local variable from function
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="remove_local",
            function_name="CalculateHealth",
            param_name="TempResult"
        )
        ```
        
        **update_local** - Update local variable type
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="update_local",
            function_name="CalculateHealth",
            param_name="TempResult",
            new_type="int"
        )
        ```
        
        ### Function Properties Action
        
        **update_properties** - Update function metadata (pure, category, etc.)
        ```python
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="update_properties",
            function_name="CalculateHealth",
            properties={
                "CallInEditor": true,
                "BlueprintPure": true,
                "Category": "Combat|Health"
            }
        )
        ```
        
        ## üéØ Complete Function Recreation Workflow:
        
        ```python
        # Step 1: Discover original function structure
        original_params = manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="list_params",
            function_name="CalculateHealth"
        )
        
        # Step 2: Create new function
        manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="create",
            function_name="CalculateHealth"
        )
        
        # Step 3: Add all parameters from original
        for param in original_params["parameters"]:
            if param["name"] != "execute":  # Skip auto-generated exec pin
                manage_blueprint_function(
                    blueprint_name="/Game/Blueprints/BP_Player2",
                    action="add_param",
                    function_name="CalculateHealth",
                    param_name=param["name"],
                    direction=param["direction"],  # ‚ö†Ô∏è Use exact value from list_params
                    type=param["type"]
                )
        
        # Step 4: Verify parameters match
        new_params = manage_blueprint_function(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="list_params",
            function_name="CalculateHealth"
        )
        ```
        
        ## ‚ö†Ô∏è Critical Parameter Direction Values:
        
        **Accepted Values (case-insensitive):**
        - **"input"** - Input parameters (left side of function node)
        - **"out"** - Output parameters (right side of function node) ‚úÖ USE THIS, NOT "output"!
        - **"return"** - Return value (alternative to "out")
        
        **Common Mistakes:**
        - ‚ùå **"output"** - NOT VALID! Will cause "Invalid direction" error
        - ‚úÖ **"out"** - CORRECT for output parameters
        - ‚úÖ **"input"** - CORRECT for input parameters
        
        ## üìä Parameter Type Format Reference:
        
        **Primitive Types:**
        - `"int"`, `"float"`, `"bool"`, `"string"`, `"byte"`, `"name"`
        - ‚ö†Ô∏è **"real"** from list_params ‚Üí use **"float"** when adding params
        
        **Object References:**
        - Format: `"object:ClassName"`
        - Examples: `"object:AActor"`, `"object:UUserWidget"`, `"object:ABP_Enemy_C"`
        
        **Struct Types:**
        - Format: `"struct:StructName"`
        - Examples: `"struct:FVector"`, `"struct:FRotator"`
        
        **Container Types:**
        - Arrays: `"array<float>"`, `"array<object:AActor>"`
        - Maps: Not directly supported via simple type strings
        
        **Execution Flow:**
        - `"exec"` - Execution pins (automatically created for first output parameter)
        
        ## üîç Response Format Examples:
        
        **list action:**
        ```json
        {
            "functions": [
                {"name": "UserConstructionScript", "node_count": 1},
                {"name": "CalculateHealth", "node_count": 5},
                {"name": "ProcessInput", "node_count": 8}
            ]
        }
        ```
        
        **get action:**
        ```json
        {
            "name": "CalculateHealth",
            "node_count": 5,
            "graph_guid": "2A845B17413D8EE95756C99189A581D9"
        }
        ```
        
        **list_params action:**
        ```json
        {
            "success": true,
            "function_name": "CalculateHealth",
            "parameters": [
                {"name": "BaseHealth", "direction": "input", "type": "float"},
                {"name": "Modifier", "direction": "input", "type": "float"},
                {"name": "execute", "direction": "out", "type": "exec"},
                {"name": "ResultHealth", "direction": "out", "type": "float"}
            ],
            "count": 4
        }
        ```
        
        ## üéØ Integration with Node Management:
        
        After creating functions with parameters, use manage_blueprint_node with graph_scope="function"
        and function_name to add nodes to the function graph.
        
        ## ‚ö†Ô∏è CRITICAL WORKFLOW ORDER:
        
        1. **Variables First**: Create all Blueprint variables
        2. **Functions Second**: Create functions and add parameters
        3. **Local Variables Third**: Add function-local variables
        4. **Nodes Last**: Add nodes to function graphs
        
        **Why this order matters:** Nodes that reference non-existent variables/functions will fail!
        
        ## üí° Pro Tips:
        
        1. Always use `list_params` to discover original function signatures before recreation
        2. The `execute` output pin is auto-created when you add your first output parameter
        3. Direction must be exactly `"input"` or `"out"` (not "output"!)
        4. Type `"real"` from list_params should be `"float"` when adding params
        5. Object types require `"object:"` prefix: `"object:ABP_Enemy_C"`
        6. Use full Blueprint paths: `"/Game/Blueprints/BP_Player"` not `"BP_Player"`
        """

        payload: Dict[str, Any] = {
            "blueprint_name": blueprint_name,
            "action": action,
        }

        _merge(
            payload,
            {
                "function_name": function_name,
                "param_name": param_name,
                "direction": direction,
                "type": type,
                "new_type": new_type,
                "new_name": new_name,
                "properties": properties,
            },
        )

        if extra:
            _merge(payload, extra)

        return _dispatch("manage_blueprint_function", payload)

    logger.info("Unified Blueprint node tools registered")


def manage_blueprint_node_test(
    blueprint_name: str,
    action: str,
    **params: Any,
) -> Dict[str, Any]:
    """Lightweight helper for exercising the MCP contract in tests."""

    result = {
        "success": True,
        "blueprint_name": blueprint_name,
        "action": action,
        "params": params,
        "message": "Test helper executed successfully.",
    }
    logger.debug("manage_blueprint_node_test payload: %s", result)
    return result
