"""
Unified Blueprint node management tools for the VibeUE MCP server.

This module provides a unified interface for performing various operations on Blueprint nodes,
such as adding, removing, and connecting nodes, as well as managing Blueprint functions and variables.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from mcp.server.fastmcp import Context, FastMCP

logger = logging.getLogger("UnrealMCP")


def _merge(target: Dict[str, Any], values: Dict[str, Any]) -> None:
    """Merge non-``None`` values into ``target`` in-place."""
    for key, value in values.items():
        if value is not None:
            target[key] = value


def register_node_tools(mcp: FastMCP) -> None:
    """Register unified Blueprint node MCP tools."""

    def _dispatch(command: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        from vibe_ue_server import get_unreal_connection

        unreal = get_unreal_connection()
        if not unreal:
            logger.error("Failed to connect to Unreal Engine")
            return {"success": False, "message": "Failed to connect to Unreal Engine"}

        logger.info("Dispatching %s with payload: %s", command, payload)
        response = unreal.send_command(command, payload)
        if not response:
            logger.error("No response from Unreal Engine")
            return {"success": False, "message": "No response from Unreal Engine"}

        logger.debug("%s response: %s", command, response)
        return response

    @mcp.tool()
    def manage_blueprint_node(
        ctx: Context = None,  #  Made optional - framework should inject, but AI doesn't need to pass it
        blueprint_name: str = None,
        action: str = None,
        graph_scope: str = "event",
        function_name: Optional[str] = None,
        node_id: Optional[str] = None,
        node_identifier: Optional[str] = None,
        node_type: Optional[str] = None,
        node_params: Optional[Dict[str, Any]] = None,
        node_config: Optional[Dict[str, Any]] = None,
        position: Optional[List[float]] = None,
        node_position: Optional[List[float]] = None,
        source_node_id: Optional[str] = None,
        source_pin: Optional[str] = None,
        target_node_id: Optional[str] = None,
        target_pin: Optional[str] = None,
        disconnect_pins: Optional[bool] = None,
        property_name: Optional[str] = None,
        property_value: Optional[Any] = None,
        include_functions: Optional[bool] = None,
        include_macros: Optional[bool] = None,
        include_timeline: Optional[bool] = None,
        extra: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Ô∏è **MULTI-ACTION BLUEPRINT NODE MANAGER**: Universal tool for all Blueprint node operations.

         **External Targets Supported (Sept 2025)**: Supply the optional metadata fields below to spawn fully configured
        nodes for engine helpers and Blueprint casts without manual cleanup.
        - `node_params.function_name` + `node_params.function_class` (or `FunctionReference.MemberParent`) for
          static/global calls such as `UGameplayStatics::GetPlayerController`.
        - `node_params.cast_target` (soft class path or Blueprint class name) for `Cast To <Class>` nodes.
        The server now resolves these descriptors, loads the referenced class, and reconstructs the node so the expected
        pins appear immediately.

        ## Supported Actions:
        - **discover**: Discover available node types with metadata (returns node descriptors with spawner_key)
        - **create**: Create new nodes (use spawner_key from discover action for exact creation)
        - **connect**: Connect pins between nodes (requires source/target node_id and pin names)
        - **connect_pins**: Batch connect pins with schema validation, conversion helpers, and diagnostics
        - **disconnect**: Disconnect pins (requires source/target node_id and pin names)
        - **disconnect_pins**: Break specific links or clear entire pins using the new payload format
        - **delete**: Remove nodes (requires node_id)
        - **move**: Reposition nodes (requires node_id and position)
        - **list**: List all nodes in graph (returns node inventory)
        - **describe**: Rich node + pin metadata payload (deterministic ordering)
        - **reset_pin_defaults**: Restore specified pins (or every pin) to their autogenerated default values
        - **get_details**: Get detailed node information (requires node_id)
        - **configure**: Set pin default values and apply node configuration (requires node_id, property_name, property_value)
        - **split** / **split_pins**: Split struct pins into sub-pins (requires node_id and pin names)
        - **recombine** / **recombine_pins** / **unsplit**: Collapse previously split pins back into their parent pin
        - **refresh_node**: Reconstruct a single Blueprint node (equivalent to right-click ‚Üí Refresh Node)
        - **refresh_nodes**: Refresh every node in the Blueprint (mirrors Blueprint ‚Üí Refresh All Nodes)

        ## Context Requirements:
        - **graph_scope**: "event" (Event Graph) or "function" (Function Graph)
        - **function_name**: Required when graph_scope="function" - specify target function name
        - **blueprint_name**: Always required - target Blueprint name

        ## Discovery Action Parameters (action="discover"):
        
        Pass these parameters in the `extra` dict when using action="discover":
        
        - **category**: Filter by node category (Flow Control, Math, Variables, Functions, etc.)
        - **search_term**: Text filter for node names, descriptions, keywords
        - **include_functions**: Whether to include function call nodes (default: True)
        - **include_variables**: Whether to include variable get/set nodes (default: True)
        - **include_events**: Whether to include event nodes (default: True)
        - **max_results**: Maximum number of nodes to return (default: 100)
        - **return_descriptors**: Whether to return complete descriptors with spawner_key (default: True)
        
        Example:
        ```python
        manage_blueprint_node(
            blueprint_name="BP_Player",
            action="discover",
            graph_scope="event",
            extra={
                "category": "Flow Control",
                "search_term": "Branch",
                "include_functions": True,
                "max_results": 50,
                "return_descriptors": True
            }
        )
        ```

        ## Multi-Action Usage Patterns:

        ### Pattern 1: Node Discovery Workflow (RECOMMENDED)
        ```python
        # üÜï BEST PRACTICE: Discover available nodes first
        
        # 1. Discover nodes with complete metadata
        result = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="discover",
            extra={
                "search_term": "GetPlayerController",
                "return_descriptors": True
            }
        )
        
        # 2. Result includes spawner_key for each variant:
        # {
        #   "success": true,
        #   "categories": {
        #     "|Game": [
        #       {
        #         "name": "Get Player Controller",
        #         "spawner_key": "GameplayStatics::GetPlayerController",
        #         "expected_pin_count": 3,
        #         "is_static": true,
        #         "pins": [...]
        #       }
        #     ]
        #   }
        # }
        
        # 3. Create using EXACT spawner_key (NO AMBIGUITY!)
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            graph_scope="function",
            function_name="MyFunction",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        ```

        ### Pattern 2: Descriptor-Based Node Creation
        ```python
        # üÜï BEST PRACTICE: Use spawner_key for exact node creation
        
        # 1. Discover with complete metadata (returns descriptors by default)
        nodes = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="discover",
            extra={"search_term": "GetPlayerController"}
        )
        
        # 2. AI examines ALL variants with complete info:
        # - "GameplayStatics::GetPlayerController" (3 input pins, static)
        # - "CheatManager::GetPlayerController" (1 pin, instance method)
        
        # 3. Create using EXACT spawner_key (NO AMBIGUITY!)
        result = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            graph_scope="function",
            function_name="MyFunction",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        #  Result: Exact variant created, correct pin count guaranteed!
        ```

        ### Pattern 3: Legacy Node Creation (Fuzzy Search)
        ```python
        # Ô∏è LEGACY: Using node_type triggers fuzzy search (less reliable)
        result = manage_blueprint_node("BP_Player", action="create", node_type="Branch")
        node_id = result["node_id"]
        manage_blueprint_node("BP_Player", action="move", node_id=node_id, position=[200, 100])
        ```

        ### Pattern 4: Node Connection Workflow
        ```python
        # List ‚Üí Identify ‚Üí Connect ‚Üí Verify
        nodes = manage_blueprint_node("BP_Player", action="list", graph_scope="function", 
                                     function_name="MyFunction")
        
        #  CORRECT: Use connect_pins with extra parameter containing connections array
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="connect_pins",
            graph_scope="function",
            function_name="MyFunction",
            extra={
                "connections": [{
                    "source_node_id": "NODE_GUID_1",
                    "source_pin_name": "ReturnValue",
                    "target_node_id": "NODE_GUID_2",
                    "target_pin_name": "InputValue"
                }]
            }
        )
        ```

        ### Pattern 5: Function Graph Operations
        ```python
        # Function context requires function_name
        manage_blueprint_node("BP_Player", action="create", graph_scope="function",
                              function_name="CalculateHealth", node_type="Add", position=[100, 50])
        ```

        ### Pattern 6: Refreshing nodes to clear stale state
        ```python
        # Rebuild a single node (same as right-click ‚Üí Refresh Node)
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="refresh_node",
            node_id="{NODE_GUID}"
        )

        # Refresh every node in the Blueprint (Blueprint ‚Üí Refresh All Nodes)
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="refresh_nodes"
        )
        ```

        ### Pattern 6: Resetting stale default values
        ```python
        # Clear a single pin back to its autogenerated default
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="reset_pin_defaults",
            node_id="{NODE_GUID}",
            extra={"pins": ["In Widget To Focus"]}
        )

        # Reset every pin on the node and compile afterwards
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player2",
            action="reset_pin_defaults",
            node_id="{NODE_GUID}",
            extra={"reset_all": True, "compile": True}
        )
        ```

        ### Pattern 7: Setting Pin Default Values
        ```python
        # Create a node and set default values on input pins
        result = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            graph_scope="function",
            function_name="CalculateDamage",
            node_params={"spawner_key": "KismetMathLibrary::RandomIntegerInRange"},
            position=[300, 100]
        )
        
        node_id = result["node_id"]
        
        # Set Min value
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="configure",
            node_id=node_id,
            property_name="Min",
            property_value=10
        )
        
        # Set Max value
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="configure",
            node_id=node_id,
            property_name="Max",
            property_value=50
        )
        
        # Verify values were set (optional)
        details = get_node_details(
            blueprint_name="/Game/Blueprints/BP_Player",
            node_id=node_id
        )
        print(f"Pin values: {[(p['name'], p.get('default_value')) for p in details['node']['pins']]}")
        ```

        ##  Pin Connection System (CRITICAL):

        ###  CORRECT Connection Format:
        
        The `connect_pins` action requires connections to be passed via the `extra` parameter:
        
        ```python
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="connect_pins",
            graph_scope="function",
            function_name="MyFunction",
            extra={
                "connections": [
                    {
                        "source_node_id": "F937A5914C523D1AB3532C8C4125C0B7",  # Node GUID
                        "source_pin_name": "ReturnValue",                      # Pin name
                        "target_node_id": "64DE8C1B47F7EEDA2B713B8604257954",  # Node GUID
                        "target_pin_name": "self"                              # Pin name
                    },
                    # Multiple connections can be made at once
                    {
                        "source_node_id": "64DE8C1B47F7EEDA2B713B8604257954",
                        "source_pin_name": "ReturnValue",
                        "target_node_id": "B3DC700344C6DA7C35FD48B872A57458",
                        "target_pin_name": "Object"
                    }
                ]
            }
        )
        ```
        
        ###  Getting Node IDs and Pin Names:
        
        Use `action="describe"` to get node GUIDs and pin names:
        
        ```python
        # Get all nodes and their pins
        result = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="describe",
            graph_scope="function",
            function_name="MyFunction"
        )
        
        # Result contains nodes with:
        # - node_id: "{GUID}" format
        # - pins: array with pin_id and name for each pin
        ```
        
        ### Connection Payload Fields:
        
        Each connection object can contain:
        - **source_node_id** (required): Source node GUID
        - **source_pin_name** (required): Name of source pin
        - **target_node_id** (required): Target node GUID  
        - **target_pin_name** (required): Name of target pin
        - **allow_conversion_node** (optional): Allow automatic conversion nodes (default: true)
        - **allow_promotion** (optional): Allow type promotion/array wrapping (default: true)
        - **break_existing_links** (optional): Break existing connections first (default: true)

                ##  Pin Split/Recombine Patterns

                - Use `action="split"` (or `"split_pins"`) with `extra={"pins": ["MyStruct"]}` to split one or more struct pins.
                - Use `action="recombine"` / `"unsplit"` with the same payload shape to collapse sub-pins back into the parent pin.
                - Alternatively, call `action="configure"` and pass
                    ```python
                    node_config={
                            "pin_operations": [
                                    {"action": "split", "pin": "MyStruct"},
                                    {"action": "recombine", "pin": "OldStruct"}
                            ]
                    }
                    ```
                    to batch property edits and pin transforms in a single request.

        ## Action-Specific Parameters:

        **create**: 
        - **RECOMMENDED**: node_params with spawner_key (from get_available_blueprint_nodes)
        - **LEGACY**: node_type (triggers fuzzy search, less reliable)
        - **position**: [X, Y] coordinates for node placement (CRITICAL for readable layouts)
          - X increases to the RIGHT (left-to-right flow)
          - Y increases DOWNWARD
          - **Best Practice**: Use increasing X values (e.g., [0, 100], [300, 100], [600, 100]) for left-to-right execution flow
          - **Common Mistake**: Decreasing X values creates backward/unreadable graphs
          - Typical spacing: 250-400 units horizontal, 100-200 units vertical
        - node_params (CRITICAL for variable nodes, casts, and exact node creation)
        
        **connect_pins**: extra with connections array (see above)  USE THIS FOR CONNECTIONS
        **disconnect_pins**: extra with connections array or pin_ids list
        **delete**: node_id
        **move**: node_id, position
        **list**: (no additional parameters)
        **describe**: node_id (optional - if omitted, describes all nodes)
        **configure**: node_id, property_name (pin name), property_value (pin default value)
        - Use to set default values on input pins
        - Get pin names from get_node_details() or get_available_blueprint_nodes()
        - Example: property_name="Min", property_value=10
        **reset_pin_defaults**: node_id, extra with "pins" array or "reset_all" flag
        **get_details**: node_id (returns pins with current default values)
        **refresh_node**: node_id or node_identifier required; optional `compile` (default `True`) to auto-compile after refresh
        **refresh_nodes**: blueprint-level refresh; optional `compile` (default `True`)
        - Pass `extra={"compile": False}` to skip the compile step when needed

        ##  node_params Patterns (VALIDATED Oct 2025):

        ### üÜï Spawner Key (EXACT NODE CREATION - RECOMMENDED)
        ```python
        # Get spawner_key from discovery
        nodes = get_available_blueprint_nodes(
            blueprint_name="/Game/Blueprints/BP_Player",
            search_term="GetPlayerController"
        )
        
        # Use spawner_key for exact creation
        manage_blueprint_node(
            action="create",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        #  Creates EXACT variant with correct pin count
        #  No ambiguity, no fuzzy searching, no wrong variants
        # Ô∏è Spawner keys mirror the Blueprint palette display text. When copying names that
        #    include underscores (e.g., variables like ``Death_Niagara_System``), replace
        #    them with spaces so the key matches the node title (``GET Death Niagara System``).
        #    The tool now performs this normalization automatically, but copying the exact
        #    descriptor text avoids ambiguity.
        ```

        ### Variable Set Nodes  REQUIRED
        ```python
        manage_blueprint_node(
            action="create",
            node_type="SET Microsub HUD",  # or "Set Microsub HUD"
            node_params={"variable_name": "Microsub HUD"},  # ‚Üê CRITICAL!
            position=[1100, 100]
        )
        # Creates 5-pin node: execute, then, Microsub HUD (input), Output_Get
        # Without node_params: Only 2 pins (broken node)
        ```

        ### Variable Get Nodes  REQUIRED
        ```python
        manage_blueprint_node(
            action="create",
            node_type="GET Health",  # or "Get Health"
            node_params={"variable_name": "Health"},  # ‚Üê CRITICAL!
            position=[100, 50]
        )
        # Creates proper getter with value output pin
        ```

        ### Cast Nodes  REQUIRED for Blueprint Classes
        ```python
        manage_blueprint_node(
            action="create",
            node_type="Cast To BP_MicrosubHUD",
            node_params={
                "cast_target": "/Game/Blueprints/HUD/BP_MicrosubHUD.BP_MicrosubHUD_C"
            },  # ‚Üê CRITICAL! Full path + _C suffix
            position=[800, 100]
        )
        # Creates 6-pin node with typed output: execute, then, CastFailed, Object, AsBP Microsub HUD
        # Format: /Full/Package/Path/BP_ClassName.BP_ClassName_C
        ```

        ### Function Call Nodes Ô∏è SITUATIONAL
        ```python
        # Most function calls work without node_params
        manage_blueprint_node(
            action="create",
            node_type="Get HUD",
            position=[500, 100]
        )
        
        # Known Issue: "Get Player Controller" shows CheatManager warning
        # Workaround: Works correctly despite warning (C++ fix planned)
        manage_blueprint_node(
            action="create",
            node_type="Get Player Controller",
            position=[200, 100]
        )
        # Shows warning but ReturnValue is correct PlayerController type
        ```

        ##  Validation Workflow:
        ```python
        # 1. Create node with node_params
        result = manage_blueprint_node(
            action="create",
            node_type="SET Health",
            node_params={"variable_name": "Health"}
        )
        
        # 2. Validate pin count (CRITICAL!)
        expected_pins = {
            "variable_set": 5,    # execute, then, value_input, Output_Get
            "variable_get": 2,    # value_output (+ optional self)
            "cast": 6,            # execute, then, CastFailed, Object, AsCastTarget
        }
        
        # 3. If pin_count < expected, node configuration failed
        if result.get("pin_count", 0) < expected_pins["variable_set"]:
            print("Ô∏è Node missing pins - check node_params!")
        
        # 4. Use describe to inspect before connecting
        manage_blueprint_node(
            action="describe",
            extra={"node_id": result["node_id"]}
        )
        ```

        ## Common Pin Names by Node Type:
        
        - **Function Entry**: "then" (exec output)
        - **Function Call**: "self" (target input), "ReturnValue" (output), "execute" (exec input)
        - **Cast Node**: "execute" (exec in), "then" (exec out success), "CastFailed" (exec out fail), "Object" (cast input), "As[ClassName]" (typed output)
        - **Variable Get**: Variable name (output)
        - **Variable Set**: "execute" (exec in), "then" (exec out), Variable name (value input), "Output_Get" (optional)
        - **Branch**: "execute" (exec in), "Condition" (bool input), "True" (exec out), "False" (exec out)

        ##  Node Creation Best Practices:

        ###  RECOMMENDED: Descriptor-Based Creation (Oct 2025)
        ```python
        # 1. Use discover action to get complete metadata
        nodes = manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="discover",
            extra={"search_term": "GetPlayerController"}
        )
        
        # 2. Examine spawner_key, expected_pin_count, function_metadata
        # - "GameplayStatics::GetPlayerController" ‚Üí 4 pins (exec + 3 data pins)
        # - "CheatManager::GetPlayerController" ‚Üí 2 pins (exec + 1 data pin)
        
        # 3. Create with exact spawner_key
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"}
        )
        # Result: EXACT variant, guaranteed correct pin count!
        ```

        ### Ô∏è LEGACY: Fuzzy Search (Less Reliable)
        ```python
        # Old way: Uses fuzzy search, may create wrong variant
        manage_blueprint_node(
            blueprint_name="/Game/Blueprints/BP_Player",
            action="create",
            node_type="Get Player Controller"  # Ambiguous!
        )
        # May create CheatManager variant instead of GameplayStatics
        ```
        
         **Troubleshooting**:
        | Problem | Cause | Solution |
        |---------|-------|----------|
        | Variable Set has only 2 pins | Missing node_params.variable_name | Add variable_name to node_params |
        | Cast shows generic Object type | Missing node_params.cast_target | Add full Blueprint path with _C suffix |
        | Function shows wrong context | C++ plugin issue (Get Player Controller) | Use anyway - output type is correct |
        | Pins don't match original BP | Wrong node_type or missing node_params | Use discover action first |
    | Warnings about missing overrides | Node cache is stale after structural edits | Call manage_blueprint_node(..., action="refresh_node") |

         **Advanced Multi-Action Examples**:
        ```python
        # Create variable getter, position it, connect to branch
        getter = manage_blueprint_node("BP_Player", "create", node_type="Get Health")
        manage_blueprint_node("BP_Player", "move", node_id=getter["node_id"], position=[0, 100])
        manage_blueprint_node("BP_Player", "connect",
                              source_node_id=getter["node_id"], source_pin="Health",
                              target_node_id="Branch_1", target_pin="Condition")
        ```
        """

        # Handle discovery action in Python (doesn't need C++ dispatch)
        if action and action.lower() in ["discover", "get_available_nodes", "search_nodes"]:
            # Extract discovery parameters from extra dict
            discover_params = extra or {}
            return _get_available_blueprint_nodes_internal(
                blueprint_name=blueprint_name,
                category=discover_params.get("category", ""),
                search_term=discover_params.get("search_term", ""),
                graph_scope=graph_scope or "event",
                include_functions=discover_params.get("include_functions", True),
                include_variables=discover_params.get("include_variables", True),
                include_events=discover_params.get("include_events", True),
                max_results=discover_params.get("max_results", 100),
                return_descriptors=discover_params.get("return_descriptors", True),
            )

        normalized_node_params = node_params

        payload: Dict[str, Any] = {
            "blueprint_name": blueprint_name,
            "action": action,
            "graph_scope": graph_scope,
        }

        resolved_node_type = node_type or node_identifier
        _merge(
            payload,
            {
                "function_name": function_name,
                "node_id": node_id,
                "node_type": resolved_node_type,
                "node_identifier": resolved_node_type,
                "node_params": normalized_node_params,
                "node_config": node_config,
                "position": position,
                "node_position": node_position,
                "source_node_id": source_node_id,
                "source_pin": source_pin,
                "target_node_id": target_node_id,
                "target_pin": target_pin,
                "disconnect_pins": disconnect_pins,
                "property_name": property_name,
                "property_value": property_value,
                "include_functions": include_functions,
                "include_macros": include_macros,
                "include_timeline": include_timeline,
            },
        )

        if extra:
            _merge(payload, extra)

        # Debug logging to understand parameter passing
        logger.info(f"manage_blueprint_node final payload: {payload}")

        # Avoid duplicating identical node configuration dictionaries
        if payload.get("node_config") is payload.get("node_params"):
            payload.pop("node_config", None)

        return _dispatch("manage_blueprint_node", payload)

    def _get_available_blueprint_nodes_internal(
        blueprint_name: str,
        category: str = "",
        search_term: str = "",
        graph_scope: str = "event",
        include_functions: bool = True,
        include_variables: bool = True,
        include_events: bool = True,
        max_results: int = 100,
        return_descriptors: bool = True,
    ) -> Dict[str, Any]:
        """
         **INTERNAL NODE DISCOVERY**: Get all available Blueprint node types with complete metadata.
        
        This is an internal function used by manage_blueprint_node(action="discover").
        External callers should use manage_blueprint_node with action="discover" instead.
        
         **NEW (Oct 2025)**: Returns complete node descriptors including:
        - **spawner_key**: Unique identifier for exact node creation (e.g., "GameplayStatics::GetPlayerController")
        - **expected_pin_count**: Number of pins the node will have
        - **function_class_path**: Full UE path to function class
        - **pins**: Complete pin metadata with types and directions
        - **is_static**, **is_pure**, **is_const**: Function properties
        
        Ô∏è **USAGE NOTE**: This is an internal function. Use manage_blueprint_node(action="discover") instead:
        
        ```python
        #  CORRECT: Use discover action
        result = manage_blueprint_node(
            blueprint_name="BP_Player",
            action="discover",
            extra={"search_term": "GetPlayerController"}
        )
        ```
        
         **PRIMARY USE CASES**:
        - **Before Creating Nodes**: Find exact node type names (e.g., "Branch", "Print String", "Cast To Object")
        - **Node Type Resolution**: When you know what you want to do but need the precise node name
        - **Category Exploration**: Browse available nodes by category (Flow Control, Math, Variables, etc.)
        - **Function-Specific Nodes**: Discover nodes available in different graph contexts
        
         **TYPICAL AI WORKFLOW**:
        ```python
        # 1. User says: "Create a GetPlayerController node"
        result = manage_blueprint_node(
            blueprint_name="BP_Player",
            action="discover",
            extra={"search_term": "GetPlayerController"}
        )
        
        # 2. Result includes spawner_key for each variant:
        # {
        #   "success": true,
        #   "categories": {
        #     "|Game": [
        #       {
        #         "name": "Get Player Controller",
        #         "spawner_key": "GameplayStatics::GetPlayerController",
        #         "expected_pin_count": 3,
        #         "function_class": "GameplayStatics",
        #         "is_static": true,
        #         "pins": [...]
        #       },
        #       {
        #         "name": "Get Player Controller", 
        #         "spawner_key": "CheatManager::GetPlayerController",
        #         "expected_pin_count": 1,
        #         "function_class": "CheatManager",
        #         "is_static": false,
        #         "pins": [...]
        #       }
        #     ]
        #   }
        # }
        
        # 3. Use exact spawner_key for creation (NO AMBIGUITY!)
        manage_blueprint_node(
            blueprint_name="BP_Player", 
            action="create",
            node_params={"spawner_key": "GameplayStatics::GetPlayerController"},
            position=[200, 100]
        )
        ```
        
         **Search Strategies**:
        - **By Intent**: category="Flow Control" for conditionals, loops
        - **By Function**: category="Math" for calculations
        - **By Action**: category="Variables" for data operations  
        - **By Context**: graph_scope="function" vs "event" for appropriate nodes
        
        Args:
            blueprint_name: Name of the target Blueprint to get nodes for
            category: Filter by node category (Flow Control, Math, Variables, Functions, etc.)
            search_term: Text filter for node names, descriptions, and keywords (like Unreal's Add Action search)
            graph_scope: Context for node discovery ("event" for Event Graph, "function" for Function Graph)
            include_functions: Whether to include function call nodes
            include_variables: Whether to include variable get/set nodes
            include_events: Whether to include event nodes  
            max_results: Maximum number of nodes to return (default: 100)
            return_descriptors: Whether to return complete descriptors with spawner_key (default: True)
            
        Returns:
            Dict containing:
            - success: boolean indicating if discovery completed
            - categories: dict of node categories with arrays of available nodes
            - total_nodes: total number of nodes found
            - error: string (only if success=false)
            
         **Node Metadata Structure** (when return_descriptors=True):
        Each discovered node includes:
        - name: Exact node type name to use in manage_blueprint_node
        - spawner_key: Unique identifier for exact creation (e.g., "GameplayStatics::GetPlayerController")
        - category: Node category for organization
        - description: What the node does
        - keywords: Search terms for semantic discovery
        - type: Node classification (function_call, variable_get, etc.)
        - expected_pin_count: Total pins this node will have
        - function_class: Class name (for function nodes)
        - function_class_path: Full UE path to class
        - is_static: Whether function is static
        - is_pure: Whether function is pure (no exec pins)
        - pins: Array of complete pin descriptors with names, types, directions
        
         **Smart Usage Examples**:
        ```python
        # Find print/debug nodes
        manage_blueprint_node("BP_Player", action="discover", 
                            extra={"category": "Development"})
        
        # Search for "Play Sound" nodes like Unreal's Add Action menu
        manage_blueprint_node("BP_Player", action="discover",
                            extra={"search_term": "Play Sound"})
        
        # Find mathematical operations
        manage_blueprint_node("BP_Player", action="discover",
                            extra={"category": "Math"})
        
        # Search for specific functions - find all "Location" related nodes
        manage_blueprint_node("BP_Player", action="discover",
                            extra={"search_term": "Location"})
        
        # Combined filtering: Audio category with "Play" in the name
        manage_blueprint_node("BP_Player", action="discover",
                            extra={"category": "Audio", "search_term": "Play"})
        
        # Find variable operations
        manage_blueprint_node("BP_Player", action="discover",
                            extra={"category": "Variables"})
        ```
        
         **AI Integration**: This tool enables data-driven Blueprint development by providing
        exact node names that work reliably, eliminating guesswork and trial-and-error.
        
        Ô∏è **CRITICAL: node_params Requirements** (Validated Oct 3, 2025):
        
        Some node types REQUIRE `node_params` in manage_blueprint_node() to work correctly:
        
        **Variable Set Nodes** (REQUIRED):
        - Must include: `node_params={"variable_name": "VariableName"}`
        - Without it: Creates broken 2-pin node (only execute, then)
        - With it: Creates proper 5-pin node with value input
        - Example:
          ```python
          manage_blueprint_node(
              action="create",
              node_type="SET Health",
              node_params={"variable_name": "Health"}
          )
          ```
        
        **Variable Get Nodes** (REQUIRED):
        - Must include: `node_params={"variable_name": "VariableName"}`
        - Example:
          ```python
          manage_blueprint_node(
              action="create", 
              node_type="GET Health",
              node_params={"variable_name": "Health"}
          )
          ```
        
        **Cast Nodes** (REQUIRED for Blueprint types):
        - Must include: `node_params={"cast_target": "/Full/Path/BP_Class.BP_Class_C"}`
        - Format: Full package path + "." + ClassName + "_C"
        - Without it: Creates generic cast with wrong type
        - With it: Creates typed cast with proper Blueprint class
        - Example:
          ```python
          manage_blueprint_node(
              action="create",
              node_type="Cast To BP_MicrosubHUD",
              node_params={
                  "cast_target": "/Game/Blueprints/HUD/BP_MicrosubHUD.BP_MicrosubHUD_C"
              }
          )
          ```
        
        **Function Call Nodes** (SITUATIONAL):
        - Some functions may show compiler warnings with wrong context
        - Known issue: "Get Player Controller" creates CheatManager context
        - Workaround: Node works correctly despite warning
        - C++ plugin fix planned for future release
        
         **Validation Tip**:
        After creating complex nodes, use `manage_blueprint_node(action="describe")` 
        to verify pin count and configuration before connecting.
        
         **See Also**:
        - `manage_blueprint_node()` for creation with node_params
        - node-tools-improvements.md for complete patterns guide
        """
        
        payload = {
            "blueprint_name": blueprint_name,
            "category": category,
            "search_term": search_term,
            "graph_scope": graph_scope,
            "include_functions": include_functions,
            "include_variables": include_variables,
            "include_events": include_events,
            "max_results": max_results,
            "return_descriptors": return_descriptors,
        }

        return _dispatch("get_available_blueprint_nodes", payload)

    # Ô∏è REMOVED Oct 4, 2025: discover_blueprint_nodes_with_descriptors tool
    # Functionality merged into get_available_blueprint_nodes(return_descriptors=True)
    # This maintains a cleaner API with a single unified discovery tool

    # Ô∏è MOVED Oct 4, 2025: manage_blueprint_function tool
    # Extracted to its own file: tools/manage_blueprint_function.py
    # This completes the 1-file-per-tool architecture (9 files for 9 tools)

    logger.info("Unified Blueprint node tools registered")


def manage_blueprint_node_test(
    blueprint_name: str,
    action: str,
    **params: Any,
) -> Dict[str, Any]:
    """Lightweight helper for exercising the MCP contract in tests."""

    result = {
        "success": True,
        "blueprint_name": blueprint_name,
        "action": action,
        "params": params,
        "message": "Test helper executed successfully.",
    }
    logger.debug("manage_blueprint_node_test payload: %s", result)
    return result
