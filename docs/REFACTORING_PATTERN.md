# Blueprint Node Commands Refactoring Pattern

## Overview

This document describes the refactoring pattern for migrating blueprint node management logic from `BlueprintNodeCommands.cpp` command handlers to the `BlueprintNodeService`.

## Motivation

The original `HandleManageBlueprintNode` routes to 21+ different action handlers, many of which contain complex blueprint manipulation logic mixed with JSON parsing and response building. This refactoring aims to:

1. **Separate concerns**: Core blueprint operations go in NodeService, JSON I/O stays in command handlers
2. **Improve testability**: Service methods can be tested independently
3. **Reduce duplication**: Common operations are centralized in NodeService
4. **Enable reuse**: Other parts of the codebase can use NodeService directly

## Architecture

### Before Refactoring
```
HandleManageBlueprintNode()
├─> HandleConnectPins() (504 lines!)
│   └─> Manual pin resolution, schema operations, transactions, JSON building
├─> HandleDisconnectPins() (392 lines!)
│   └─> Manual pin resolution, schema operations, transactions, JSON building
├─> HandleResetPinDefaults() (270 lines!)
│   └─> Manual pin resolution, schema operations, transactions, JSON building
└─> ... 18 more handlers
```

### After Refactoring
```
HandleManageBlueprintNode()
├─> HandleConnectPins() (~60 lines)
│   ├─> Parse JSON parameters
│   ├─> DiscoveryService->FindBlueprint()
│   ├─> NodeService->ConnectPins() (core logic)
│   └─> Build JSON response
├─> HandleResetPinDefaults() (~60 lines)
│   ├─> Parse JSON parameters  
│   ├─> DiscoveryService->FindBlueprint()
│   ├─> For each pin: NodeService->ResetPinToDefault()
│   └─> Build JSON response
└─> ...

NodeService
├─> ConnectPins() - Core pin connection logic
├─> DisconnectPins() - Core pin disconnection logic
├─> SplitPin() - Split a struct pin into sub-pins
├─> RecombinePin() - Recombine a split pin
├─> ResetPinToDefault() - Reset pin to autogenerated default
└─> ... other core operations
```

## Refactoring Steps

### 1. Add NodeService Method

Add a focused method to `FBlueprintNodeService` that handles ONE core operation:

```cpp
// In BlueprintNodeService.h
TResult<void> ResetPinToDefault(UBlueprint* Blueprint, 
                                const FString& NodeId, 
                                const FString& PinName);

// In BlueprintNodeService.cpp
TResult<void> FBlueprintNodeService::ResetPinToDefault(UBlueprint* Blueprint, 
                                                        const FString& NodeId, 
                                                        const FString& PinName)
{
    // 1. Validate parameters
    if (!Blueprint) {
        return TResult<void>::Error(ErrorCodes::BLUEPRINT_NOT_FOUND, TEXT("Blueprint is null"));
    }
    
    // 2. Find node using helper methods
    TArray<UEdGraph*> Graphs;
    GatherCandidateGraphs(Blueprint, nullptr, Graphs);
    UEdGraphNode* Node = nullptr;
    UEdGraph* Graph = nullptr;
    if (!ResolveNodeIdentifier(NodeId, Graphs, Node, Graph)) {
        return TResult<void>::Error(ErrorCodes::NODE_NOT_FOUND, TEXT("Node not found"));
    }
    
    // 3. Find pin
    UEdGraphPin* Pin = FindPin(Node, PinName);
    if (!Pin) {
        return TResult<void>::Error(ErrorCodes::PIN_NOT_FOUND, TEXT("Pin not found"));
    }
    
    // 4. Perform operation with transaction
    const FScopedTransaction Transaction(NSLOCTEXT("VibeUE", "ResetPin", "Reset Pin"));
    Graph->Modify();
    Node->Modify();
    Pin->Modify();
    
    const UEdGraphSchema_K2* Schema = Cast<UEdGraphSchema_K2>(Graph->GetSchema());
    Schema->ResetPinToAutogeneratedDefaultValue(Pin);
    
    // 5. Notify and mark modified
    Graph->NotifyGraphChanged();
    FBlueprintEditorUtils::MarkBlueprintAsModified(Blueprint);
    
    return TResult<void>::Success();
}
```

### 2. Simplify Command Handler

Refactor the command handler to use the NodeService method:

```cpp
TSharedPtr<FJsonObject> FBlueprintNodeCommands::HandleResetPinDefaults(const TSharedPtr<FJsonObject>& Params)
{
    // 1. Parse parameters
    FString BlueprintName, NodeId;
    TArray<FString> PinNames;
    // ... extract from JSON ...
    
    // 2. Find blueprint
    auto BlueprintResult = DiscoveryService->FindBlueprint(BlueprintName);
    if (!BlueprintResult.IsSuccess()) {
        return CreateErrorResponse(BlueprintResult.GetErrorCode(), 
                                  BlueprintResult.GetErrorMessage());
    }
    
    // 3. Call NodeService for each pin (batch operation)
    TArray<TSharedPtr<FJsonValue>> Results;
    int32 SuccessCount = 0;
    
    for (const FString& PinName : PinNames) {
        auto Result = NodeService->ResetPinToDefault(BlueprintResult.GetValue(), 
                                                     NodeId, 
                                                     PinName);
        
        TSharedPtr<FJsonObject> PinResult = MakeShared<FJsonObject>();
        PinResult->SetStringField(TEXT("pin_name"), PinName);
        PinResult->SetBoolField(TEXT("success"), Result.IsSuccess());
        if (!Result.IsSuccess()) {
            PinResult->SetStringField(TEXT("error"), Result.GetErrorMessage());
        } else {
            ++SuccessCount;
        }
        Results.Add(MakeShared<FJsonValueObject>(PinResult));
    }
    
    // 4. Build response
    TSharedPtr<FJsonObject> Response = MakeShared<FJsonObject>();
    Response->SetBoolField(TEXT("success"), SuccessCount == PinNames.Num());
    Response->SetArrayField(TEXT("pins"), Results);
    return Response;
}
```

## Completed Refactorings

### NodeService Methods Added
- ✅ `SplitPin()` - Splits a struct pin into sub-pins
- ✅ `RecombinePin()` - Recombines a split pin back together
- ✅ `ResetPinToDefault()` - Resets a pin to its autogenerated default value

### Handlers Already Using Services
- ✅ `HandleDeleteBlueprintNode` - Uses DiscoveryService and NodeService
- ✅ `HandleMoveBlueprintNode` - Uses DiscoveryService and NodeService
- ✅ `HandleFindBlueprintNodes` - Uses DiscoveryService and NodeService
- ✅ `HandleRefreshBlueprintNode` - Uses DiscoveryService and NodeService
- ✅ `HandleRefreshBlueprintNodes` - Uses DiscoveryService and NodeService
- ✅ `HandleListCustomEvents` - Uses DiscoveryService and GraphService
- ✅ `HandleAddBlueprintInputActionNode` - Uses DiscoveryService and NodeService

## Remaining Work

### High Priority
These handlers contain 500+ lines of complex logic that should be moved to NodeService:

1. **HandleConnectPins (504 lines)** - Needs `NodeService::ConnectPins()` implementation
   - Complex pin resolution from multiple input formats
   - Schema validation and connection rules
   - Batch connection operations
   - Reroute node special handling

2. **HandleDisconnectPins (392 lines)** - Needs `NodeService::DisconnectPins()` implementation
   - Pin pair vs single pin disconnection
   - Break all vs break specific link modes
   - Batch disconnection operations

### Medium Priority
These handlers can now use the newly added NodeService methods:

3. **HandleSplitOrRecombinePins** - Can use `NodeService::SplitPin()` and `RecombinePin()`
   - Current: ~150 lines with manual pin manipulation
   - Target: ~60 lines calling NodeService methods

4. **HandleResetPinDefaults** - Can use `NodeService::ResetPinToDefault()`
   - Current: ~270 lines with complex batch logic
   - Target: ~80 lines calling NodeService method in loop

5. **HandleConfigureBlueprintNode** - Mix of split/recombine operations
   - Current: ~170 lines
   - Target: ~70 lines using NodeService methods

### Low Priority
These are simpler or already delegated to other systems:

6. **HandleAddBlueprintNode** - Uses ReflectionCommands (keep as-is)
7. **HandleSetBlueprintNodeProperty** - Uses ReflectionCommands (keep as-is)
8. **HandleGetBlueprintNodeProperty** - Uses ReflectionCommands (keep as-is)
9. **HandleDescribeBlueprintNodes** - Mostly read-only (keep as-is)
10. **HandleGetNodeDetails** - Simple node info retrieval (keep as-is)

## Expected Impact

### Line Count Reduction
- **Current total**: ~2000+ lines in command handlers
- **Target total**: ~800-1000 lines in command handlers
- **NodeService**: ~1000 lines (new code, but reusable)

### Benefits
1. **Testability**: NodeService methods can be unit tested
2. **Reusability**: Other code can use NodeService directly
3. **Maintainability**: Single source of truth for blueprint operations
4. **Debugging**: Easier to trace issues in focused methods
5. **Documentation**: Service methods are self-documenting APIs

## Implementation Strategy

Given the scope of this refactoring:

1. **Phase 1 (✅ COMPLETED)**: Add core NodeService methods for simple operations
   - SplitPin, RecombinePin, ResetPinToDefault

2. **Phase 2 (IN PROGRESS)**: Implement batch operation methods
   - ConnectPins, DisconnectPins (very complex - needs careful design)

3. **Phase 3 (FUTURE)**: Refactor remaining handlers
   - Update each handler to use NodeService
   - Maintain backward compatibility with existing JSON API

4. **Phase 4 (FUTURE)**: Optimize and consolidate
   - Remove duplicate code
   - Add batch operation optimizations
   - Performance testing

## Notes

- The complexity in command handlers is often INHERENT to handling flexible JSON APIs
  - Supporting multiple parameter formats
  - Batch vs single operations
  - Detailed error reporting per item
- NodeService methods should focus on CORE blueprint operations
- Command handlers remain responsible for JSON parsing and response building
- Tests must pass at each phase - maintain backward compatibility
